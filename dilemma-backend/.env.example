# ============================================
# .env.example
# ============================================

# Environnement
NODE_ENV=development
PORT=3000

# Base de données PostgreSQL
# Format: postgresql://USER:PASSWORD@HOST:PORT/DATABASE
DATABASE_URL=postgresql://postgres:password@localhost:5432/dilemma_db

# Redis
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=

# JWT
# IMPORTANT: Générez une clé secrète forte en production
# Vous pouvez utiliser: node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
JWT_SECRET=your-super-secret-jwt-key-change-this-in-production-min-32-chars
JWT_EXPIRES_IN=7d

# CORS
# En développement: * pour tout autoriser
# En production: votre domaine frontend
CORS_ORIGIN=*

# Rate limiting
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX_REQUESTS=100

# AWS S3 (optionnel - pour les logos sponsors)
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_S3_BUCKET=
AWS_REGION=eu-west-1

# RevenueCat (optionnel - pour les abonnements)
REVENUECAT_API_KEY=

# Firebase (optionnel - pour les notifications push)
FIREBASE_PROJECT_ID=
FIREBASE_PRIVATE_KEY=
FIREBASE_CLIENT_EMAIL=

# ============================================
# GUIDE DE DÉMARRAGE RAPIDE
# ============================================

# 1. Installation des dépendances
npm install

# 2. Copier .env.example vers .env et configurer
cp .env.example .env
# Ensuite éditer .env avec vos valeurs

# 3. Démarrer PostgreSQL et Redis avec Docker (recommandé)
docker-compose up -d postgres redis

# OU installer PostgreSQL et Redis localement

# 4. Générer le client Prisma
npm run prisma:generate

# 5. Créer et appliquer les migrations
npm run prisma:migrate

# 6. (Optionnel) Seed la base de données avec des données de test
npm run prisma:seed

# 7. Démarrer le serveur en mode développement
npm run dev

# Le serveur démarre sur http://localhost:3000
# Testez avec: curl http://localhost:3000/health

# ============================================
# COMMANDES UTILES
# ============================================

# Développement
npm run dev              # Démarre le serveur avec hot-reload
npm run prisma:studio    # Interface graphique pour la DB
npm run lint             # Vérifier le code

# Production
npm run build            # Compile TypeScript
npm start                # Démarre le serveur compilé

# Base de données
npm run prisma:migrate   # Créer et appliquer une migration
npm run prisma:generate  # Régénérer le client Prisma
npm run prisma:seed      # Remplir avec des données de test

# ============================================
# STRUCTURE DU PROJET
# ============================================

backend/
├── src/
│   ├── config/           # Configuration (env, database, redis)
│   ├── controllers/      # Contrôleurs (logique des routes)
│   ├── middleware/       # Middlewares (auth, validation, errors)
│   ├── routes/           # Définition des routes
│   ├── services/         # Logique métier
│   ├── utils/            # Utilitaires
│   └── index.ts          # Point d'entrée
├── prisma/
│   ├── schema.prisma     # Schéma de base de données
│   └── migrations/       # Historique des migrations
├── .env                  # Variables d'environnement (ne pas commit!)
├── .env.example          # Template pour .env
├── package.json
├── tsconfig.json
└── docker-compose.yml

# ============================================
# ENDPOINTS API DISPONIBLES
# ============================================

# Authentication
POST   /api/auth/register          # Inscription
POST   /api/auth/login             # Connexion
GET    /api/auth/profile           # Profil utilisateur (auth requis)

# Dilemmes
GET    /api/dilemmas/today         # Dilemme du jour
GET    /api/dilemmas/tomorrow      # Dilemme de demain (premium)
GET    /api/dilemmas/history       # Historique (7j free, illimité premium)
GET    /api/dilemmas/:id           # Détails d'un dilemme

# Votes
POST   /api/votes                  # Voter pour un dilemme
GET    /api/votes/:dilemmaId/status          # Statut du vote
GET    /api/votes/:dilemmaId/reward          # Récupérer la récompense
POST   /api/votes/reward/track               # Tracker une interaction

# Statistiques
GET    /api/stats/dilemmas/:id/global        # Stats globales
GET    /api/stats/dilemmas/:id/gender        # Stats par genre
GET    /api/stats/dilemmas/:id/age           # Stats par âge
GET    /api/stats/dilemmas/:id/friends       # Stats entre amis
GET    /api/stats/dilemmas/:id/friends/:friendId  # Stats ami spécifique (premium)

# Amis
POST   /api/friends/request                  # Envoyer demande d'ami
POST   /api/friends/:id/accept               # Accepter demande
DELETE /api/friends/:id                      # Supprimer amitié
GET    /api/friends                          # Liste des amis
GET    /api/friends/pending                  # Demandes en attente

# Profil
PATCH  /api/users/profile                    # Mettre à jour profil

# Admin (auth + admin requis)
POST   /api/admin/dilemmas          # Créer un dilemme
GET    /api/admin/dilemmas          # Lister les dilemmes
PUT    /api/admin/dilemmas/:id      # Modifier un dilemme
DELETE /api/admin/dilemmas/:id      # Supprimer un dilemme

# Sponsors (admin uniquement)
POST   /api/sponsors                # Créer un sponsor
GET    /api/sponsors                # Lister les sponsors
GET    /api/sponsors/:id/analytics  # Analytics d'un sponsor

# ============================================
# EXEMPLE D'UTILISATION
# ============================================

# 1. S'inscrire
curl -X POST http://localhost:3000/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "email": "user@example.com",
    "password": "password123",
    "username": "johndoe"
  }'

# 2. Se connecter (récupérer le token)
curl -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "user@example.com",
    "password": "password123"
  }'

# 3. Récupérer le dilemme du jour (avec token)
curl http://localhost:3000/api/dilemmas/today \
  -H "Authorization: Bearer YOUR_TOKEN_HERE"

# 4. Voter
curl -X POST http://localhost:3000/api/votes \
  -H "Authorization: Bearer YOUR_TOKEN_HERE" \
  -H "Content-Type: application/json" \
  -d '{
    "dilemmaId": "uuid-du-dilemme",
    "choice": "A"
  }'

# ============================================
# DOCKER COMPOSE (développement)
# ============================================

# docker-compose.yml à créer à la racine:

version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    container_name: dilemma_postgres
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: dilemma_db
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    container_name: dilemma_redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  postgres_data:
  redis_data:

# Commandes Docker:
# docker-compose up -d         # Démarrer en arrière-plan
# docker-compose down          # Arrêter
# docker-compose logs -f       # Voir les logs
# docker-compose ps            # Statut des conteneurs

# ============================================
# NOTES DE SÉCURITÉ
# ============================================

# En PRODUCTION:
# 1. Changez TOUS les secrets (JWT_SECRET, DB passwords)
# 2. Configurez CORS_ORIGIN avec votre domaine uniquement
# 3. Utilisez HTTPS uniquement
# 4. Activez les limites de taux (rate limiting)
# 5. Configurez un reverse proxy (nginx)
# 6. Activez les logs de sécurité
# 7. Utilisez des variables d'environnement sécurisées
# 8. Activez les sauvegardes automatiques de la DB
# 9. Mettez à jour régulièrement les dépendances
# 10. Auditez avec: npm audit

# ============================================
# TROUBLESHOOTING
# ============================================

# Erreur: Port 3000 déjà utilisé
# Solution: Changez PORT dans .env ou tuez le processus:
# lsof -i :3000
# kill -9 <PID>

# Erreur: Cannot connect to database
# Solution: Vérifiez que PostgreSQL est démarré et DATABASE_URL correct

# Erreur: Redis connection refused
# Solution: Vérifiez que Redis est démarré

# Erreur: Prisma Client not generated
# Solution: npm run prisma:generate

# Erreur de migration Prisma
# Solution: npm run prisma:migrate reset (⚠️  efface toutes les données!)